-- Copyright (C) 2009 Yannick Parmentier
--
-- This software is a computer program whose purpose is to [describe
-- functionalities and technical features of your software].
--
-- This software is governed by the CeCILL  license under French law and
-- abiding by the rules of distribution of free software.  You can  use,
-- modify and/ or redistribute the software under the terms of the CeCILL
-- license as circulated by CEA, CNRS and INRIA at the following URL
-- "http://www.cecill.info".
--
-- As a counterpart to the access to the source code and  rights to copy,
-- modify and redistribute granted by the license, users are provided only
-- with a limited warranty  and the software's author,  the holder of the
-- economic rights,  and the successive licensors  have only  limited
-- liability.
--
-- In this respect, the user's attention is drawn to the risks associated
-- with loading,  using,  modifying and/or developing or reproducing the
-- software by the user in light of its specific status of free software,
-- that may mean  that it is complicated to manipulate,  and  that  also
-- therefore means  that it is reserved for developers  and  experienced
-- professionals having in-depth computer knowledge. Users are therefore
-- encouraged to load and test the software's suitability as regards their
-- requirements in conditions enabling the security of their systems and/or
-- data to be ensured and,  more generally, to use and operate it in the
-- same conditions as regards security.
--
-- The fact that you are presently reading this means that you have had
-- knowledge of the CeCILL license and that you accept its terms.

module LexToGeniXML (headerGenXML, formatLexGenXML)

where

import Dtypes
import Generic
import System.Time
import Data.List
import XMLprint


-- normalized functions for pretty printing
headerGenXML :: ClockTime -> String -> String
headerGenXML time pname =
    headerGeniXML time pname

formatLexGenXML :: [LexEntry] -> ClockTime -> String -> String -> String -> String -> String
formatLexGenXML lex _ _ _ _ _ =
    printXML (formatLexGeniXML lex) ""
----------


headerGeniXML :: ClockTime -> String -> String
headerGeniXML t pname = 
    let time = calendarTimeToString (toUTCTime t)
	in "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n" ++ "<!-- lexicon generated by "++pname++" at "++time++"-->\n\n"


formatLexGeniXML :: [LexEntry] -> XMLelem
formatLexGeniXML lex =
        let l = sort lex
	    in --concatMap (\x -> convertEntry x) l
	      Elem {tag      = "lexicon",
	      features = [],
	      datas    = "",
	      children = [Elem {tag      = "lemmas",
				features = [],
				datas    = "",
				children = 
				map (\x -> convertEntryXML x) l }]}


convertEntryXML :: LexEntry -> XMLelem
convertEntryXML e =
    Elem {
          tag      = "lemma",
          features = [("family", (family e))] ++ [("name", (lemma e))],
          datas    = "",
          children = [(getEquations (equations e))] ++ [(getCoanchors (coanchors e))]
                     ++ [(getInterface (iface e))] ++ [(convertFilterXML (family e) (filters e))]
                     ++ [(convertSem (sem e))]
         }


getEquations :: [Equa] -> XMLelem
getEquations eq =
    Elem {tag      = "equations",
	  features = [],
	  datas    = "",
	  children = map (\x -> convertEquaXML x) eq
         }


convertEquaXML :: Equa -> XMLelem
convertEquaXML e =
    let (fs, sn) = (snd3 e) 
        nodename =  case (fst3 e) of "anchor" -> "anchor"
                                     "anc"    -> "anchor"
                                     _        -> (fst3 e)
        fsname   =  case fs of "" -> "bot"
                               _  -> fs
        in 
        Elem {tag      = "equation",
	                 features = [("type", fsname),("node_id", nodename)],
	                 datas    = "",
	                 children = [Elem {tag      = "fs",
			                   features = [],
			                   datas    = "",
			                   children = [Elem {tag      = "f",
					                     features = [("name",sn)],
					                     datas    = "",
					                     children = [convertVal (thd3 e)]}]}]}



convertVal :: Val -> XMLelem
convertVal v =
    case v of Const (x:y:xs) -> Elem {tag      = "vAlt",
				      features = [],
				      datas    = "",
				      children = 
				      map (\e -> convertVal (Const [e])) (x:y:xs)} 
	      _ -> Elem {tag      = "sym",
			 features = [("value",(show v))],
			 datas    = "",
			 children = []}


getCoanchors :: [Coanchor] -> XMLelem
getCoanchors co =
    Elem {tag      = "coanchors",
	  features = [],
	  datas    = "",
	  children = map (\x -> convertCoanchorXML x) co
         }


convertCoanchorXML :: Coanchor -> XMLelem
convertCoanchorXML (node,lex,cat) =
    Elem {tag      = "coanchor",
	  features = [("type", "top"),("node_id", node)],
	  datas    = "",
	  children = [Elem {tag      = "fs",
			    features = [],
			    datas    = "",
			    children = [Elem {tag      = "f",
					      features = [("name","lex")],
					      datas    = "",
					      children = [convertVal (Const [lex])]}] ++
                                       [Elem {tag      = "f",
					      features = [("name","cat")],
					      datas    = "",
					      children = [convertVal (Const [cat])]}
                                       ]
                           }
                     ]
         }


getInterface :: FS -> XMLelem
getInterface iface =
    Elem {tag      = "interface",
	  features = [],
	  datas    = "",
	  children = [
                      Elem {tag      = "fs",
			    features = [],
			    datas    = "",
			    children = map (\x -> convertAttVal x) iface
                           }
                     ]
         }


convertAttVal :: AVPair -> XMLelem
convertAttVal av =
    Elem {tag      = "f",
		     features = [("name",(fst av))],
		     datas    = "",
		     children = [convertVal (snd av)]}


convertFilterXML :: String -> FS -> XMLelem
convertFilterXML fam fil =
        Elem {tag      = "filter",
	      features = [],
	      datas    = "",
	      children = [
                          Elem {tag      = "fs",
			        features = [],
			        datas    = "",
			        children = [Elem {tag      = "f",
					          features = [("name", "family")],
					          datas    = "",
					          children = [convertVal (Const [fam])] 
                                                 }] ++
                                           (map (\x -> convertAttVal x) fil)
                               }
                         ]
             }
    

convertSem :: Sem -> XMLelem
convertSem s =
        Elem {tag      = "semantics",
	      features = [],
	      datas    = "",
	      children = map (\x -> convertLit x) s
             }


convertLit :: Lit -> XMLelem
convertLit l =
        Elem {tag      = "literal",
	      features = [("label", valToString (fst3 l))] ++ [("predicate", valToString (snd3 l))],
	      datas    = "",
	      children = [
                          Elem {tag      = "args",
			        features = [],
			        datas    = "",
			        children = (map (\x -> convertVal x) (thd3 l))
                               }
                         ]
             }
