module LexToGeni (headerGen, formatLexGen)

where

import Dtypes
import Generic
import System.Time
import Data.List


-- normaliazed functions for pretty printing
headerGen :: ClockTime -> String -> String
headerGen time pname =
    headerGeni time pname

formatLexGen :: [LexEntry] -> ClockTime -> String -> String -> String -> String -> String
formatLexGen lex _ _ _ _ _ =
    formatLexGeni lex
----------


headerGeni :: ClockTime -> String -> String
headerGeni t pname = 
    let time = calendarTimeToString (toUTCTime t)
	in "%% lexicon generated by "++pname++" at "++time++"\n\n"


formatLexGeni :: [LexEntry] -> String
formatLexGeni lex =
        let l = sort lex
	    in concatMap (\x -> convertEntry x) l
	    

convertEntry :: LexEntry -> String
convertEntry e =
    (lemma e)++" "++(family e)++"  "++(getParams e)++"\n"
    ++"equations:["
    ++(concatMap (\x -> convertEqua x) (equations e))
    ++(concatMap (\x -> convertCoanchor x) (coanchors e))
    ++(convertFS (iface e))++"]\n"
    ++"filters:["++(convertFil (family e) (filters e))++"]\n"
    ++"semantics:["++(convertSem (sem e))++"]\n\n"


getParams :: LexEntry -> String
getParams e = 
    case (params e) of [] -> ""
		       _  -> "%("++(unwords $ map (\x -> convertVal x) (params e))++")"


convertEqua :: Equa -> String
convertEqua e =
    let (fs, sn) = (snd3 e) 
        in 
        case fs of "" -> case (fst3 e) of "anchor" -> (fst3 e)++"."++"bot"++"."++(sn)++":"++(convertVal (thd3 e))++" "
                                          "anc"    -> "anchor"++"."++"bot"++"."++(sn)++":"++(convertVal (thd3 e))++" "
                                          _ -> (fst3 e)++"."++(sn)++":"++(convertVal (thd3 e))++" "
                   _  -> (fst3 e)++"."++(fs)++"."++(sn)++":"++(convertVal (thd3 e))++" "


convertVal :: Val -> String
convertVal v =
    case v of Const (x:y:xs) -> concat $ intersperse "|" $ (x:y:xs)
	      Var y          -> "?"++y
	      Const [x]      -> x
	      Anonymous      -> "_" 
	      Const []       -> error "empty constant"


convertCoanchor :: Coanchor -> String
convertCoanchor (node,lex,cat) =
    node++".top.lex:"++lex++" "++
    node++".top.cat:"++cat++" "


convertFS :: FS -> String
convertFS iface =
    unwords (map (\x -> convertAttVal x) iface)


convertAttVal :: AVPair -> String
convertAttVal av =
    "interface."++(fst av)++":"++(convertVal (snd av))


convertFil :: String -> FS -> String
convertFil fam fil =
    "family:"++fam++" "++(convertFS fil)
    

convertSem :: Sem -> String
convertSem s =
    concatMap (\x -> convertLit x) s


convertLit :: Lit -> String
convertLit l =
    (convertVal (fst3 l))++":"++(convertVal (snd3 l))++"("++(unwords $ map (\x -> convertVal x) (thd3 l))++") "
